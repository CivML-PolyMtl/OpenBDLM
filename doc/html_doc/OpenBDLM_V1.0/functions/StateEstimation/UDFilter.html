<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of UDFilter</title>
  <meta name="keywords" content="UDFilter">
  <meta name="description" content="UDFILTER Do one step of the UD filter (prediction + update at time t)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">OpenBDLM_V1.0</a> &gt; <a href="#">functions</a> &gt; <a href="index.html">StateEstimation</a> &gt; UDFilter.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for OpenBDLM_V1.0/functions/StateEstimation&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>UDFilter
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>UDFILTER Do one step of the UD filter (prediction + update at time t)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [xnew, Vnew, VVnew, U_post, D_post, loglik]=UDFilter(A, C, Q, R, y, x, V, U_post, D_post) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">UDFILTER Do one step of the UD filter (prediction + update at time t) 

   SYNOPSIS:
      [xnew, Vnew, VVnew, U_post, D_post, loglik]=UDFILTER(A, C, Q, R, y, x, V, U_post, D_post)
 
   INPUT:
      A                        - real valued array (required)
                                 transition matrix

      C                        - real valued array (required)
                                 observation matrix   

      Q                        - real valued array (required)
                                 process noise covariance matrix 

      R                        - real valued array (required)
                                 observation noise covariance matrix 

      y                        - real valued array (required)
                                 available observations a time t 

      x                        - real valued array (required)
                                 posterior mean vector at time t-1

      V                        - real valued array (required)
                                 posterior covariance matrix at time t-1

      U_post                   - real valued array (required)
                                 

      D_post                   - real valued array (required)
                                 
 
   OUTPUT:
      xnew                     - real valued array (required)
                                 posterior mean vector at time t

      Vnew                     - real valued array (required)
                                 posterior covariance matrix at time t

      VVnew                    - real valued array (required)

      U_post                   - real valued array 
                                 
      D_post                   - real valued array   

      loglik                   - real 
                                 log-likelihood at time t
 
   DESCRIPTION:
      UDFILTER performs one step of the UD filter (prediction + update at time t)
      UDFILTER uses function initially developed by Brian Moore.
 
   EXAMPLES:
      [xnew, Vnew, VVnew, U_post, D_post, loglik]=UDFILTER(A, C, Q, R, y, x, V, U_post, D_post)
 
   EXTERNAL FUNCTIONS CALLED:
      myUD
 
   SUBFUNCTIONS:
      bierman_m,  thornton, KalmanGainCalc,myUnitTriSysSol
      
   See also <a href="SwitchingKalmanFilter.html" class="code" title="function [x, V, VV, S, loglik,U,D]=SwitchingKalmanFilter(data, model, misc)">SWITCHINGKALMANFILTER</a>, <a href="myUD.html" class="code" title="function [U, D] = myUD(mat,varargin)">MYUD</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="getGaussianProbability.html" class="code" title="function [prob]=getGaussianProbability(x, m, C, varargin)">getGaussianProbability</a>	GETGAUSSIANPROBABILITY Evaluate a multivariate Gaussian density</li><li><a href="myUD.html" class="code" title="function [U, D] = myUD(mat,varargin)">myUD</a>	MYUD Compute the UD decomposition</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="SwitchingKalmanFilter.html" class="code" title="function [x, V, VV, S, loglik,U,D]=SwitchingKalmanFilter(data, model, misc)">SwitchingKalmanFilter</a>	SWITCHINGKALMANFILTER Perform Switching Kalman filtering of time series</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [x_post U_post D_post] = bierman_m(z,R,H,x_prior,U_prior,D_prior)</a></li><li><a href="#_sub2" class="code">function [x_prior U_prior D_prior] = thornton(x_post,U_post,D_post,Uq,Dq,varargin)</a></li><li><a href="#_sub3" class="code">function [K isSingular] = KalmanGainCalc(P,R,varargin)</a></li><li><a href="#_sub4" class="code">function X = myUnitTriSysSol(T,Y,mode)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [xnew, Vnew, VVnew, U_post, D_post, loglik]=UDFilter(A, C, Q, R, y, x, V, U_post, D_post)</a>
0002 <span class="comment">%UDFILTER Do one step of the UD filter (prediction + update at time t)</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%   SYNOPSIS:</span>
0005 <span class="comment">%      [xnew, Vnew, VVnew, U_post, D_post, loglik]=UDFILTER(A, C, Q, R, y, x, V, U_post, D_post)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%   INPUT:</span>
0008 <span class="comment">%      A                        - real valued array (required)</span>
0009 <span class="comment">%                                 transition matrix</span>
0010 <span class="comment">%</span>
0011 <span class="comment">%      C                        - real valued array (required)</span>
0012 <span class="comment">%                                 observation matrix</span>
0013 <span class="comment">%</span>
0014 <span class="comment">%      Q                        - real valued array (required)</span>
0015 <span class="comment">%                                 process noise covariance matrix</span>
0016 <span class="comment">%</span>
0017 <span class="comment">%      R                        - real valued array (required)</span>
0018 <span class="comment">%                                 observation noise covariance matrix</span>
0019 <span class="comment">%</span>
0020 <span class="comment">%      y                        - real valued array (required)</span>
0021 <span class="comment">%                                 available observations a time t</span>
0022 <span class="comment">%</span>
0023 <span class="comment">%      x                        - real valued array (required)</span>
0024 <span class="comment">%                                 posterior mean vector at time t-1</span>
0025 <span class="comment">%</span>
0026 <span class="comment">%      V                        - real valued array (required)</span>
0027 <span class="comment">%                                 posterior covariance matrix at time t-1</span>
0028 <span class="comment">%</span>
0029 <span class="comment">%      U_post                   - real valued array (required)</span>
0030 <span class="comment">%</span>
0031 <span class="comment">%</span>
0032 <span class="comment">%      D_post                   - real valued array (required)</span>
0033 <span class="comment">%</span>
0034 <span class="comment">%</span>
0035 <span class="comment">%   OUTPUT:</span>
0036 <span class="comment">%      xnew                     - real valued array (required)</span>
0037 <span class="comment">%                                 posterior mean vector at time t</span>
0038 <span class="comment">%</span>
0039 <span class="comment">%      Vnew                     - real valued array (required)</span>
0040 <span class="comment">%                                 posterior covariance matrix at time t</span>
0041 <span class="comment">%</span>
0042 <span class="comment">%      VVnew                    - real valued array (required)</span>
0043 <span class="comment">%</span>
0044 <span class="comment">%      U_post                   - real valued array</span>
0045 <span class="comment">%</span>
0046 <span class="comment">%      D_post                   - real valued array</span>
0047 <span class="comment">%</span>
0048 <span class="comment">%      loglik                   - real</span>
0049 <span class="comment">%                                 log-likelihood at time t</span>
0050 <span class="comment">%</span>
0051 <span class="comment">%   DESCRIPTION:</span>
0052 <span class="comment">%      UDFILTER performs one step of the UD filter (prediction + update at time t)</span>
0053 <span class="comment">%      UDFILTER uses function initially developed by Brian Moore.</span>
0054 <span class="comment">%</span>
0055 <span class="comment">%   EXAMPLES:</span>
0056 <span class="comment">%      [xnew, Vnew, VVnew, U_post, D_post, loglik]=UDFILTER(A, C, Q, R, y, x, V, U_post, D_post)</span>
0057 <span class="comment">%</span>
0058 <span class="comment">%   EXTERNAL FUNCTIONS CALLED:</span>
0059 <span class="comment">%      myUD</span>
0060 <span class="comment">%</span>
0061 <span class="comment">%   SUBFUNCTIONS:</span>
0062 <span class="comment">%      bierman_m,  thornton, KalmanGainCalc,myUnitTriSysSol</span>
0063 <span class="comment">%</span>
0064 <span class="comment">%   See also SWITCHINGKALMANFILTER, MYUD</span>
0065  
0066 <span class="comment">%   AUTHORS:</span>
0067 <span class="comment">%       Luong Ha Nguyen, Ianis Gaudot, James-A Goulet</span>
0068 <span class="comment">%</span>
0069 <span class="comment">%       Inspired from the initial code of Brian Moore</span>
0070 <span class="comment">%</span>
0071 <span class="comment">%      Email: &lt;james.goulet@polymtl.ca&gt;</span>
0072 <span class="comment">%      Website: &lt;http://www.polymtl.ca/expertises/goulet-james-alexandre&gt;</span>
0073 <span class="comment">%</span>
0074 <span class="comment">%   MATLAB VERSION:</span>
0075 <span class="comment">%      Tested on 9.1.0.441655 (R2016b)</span>
0076 <span class="comment">%</span>
0077 <span class="comment">%   DATE CREATED:</span>
0078 <span class="comment">%       June 28, 2018</span>
0079 <span class="comment">%</span>
0080 <span class="comment">%   DATE LAST UPDATE:</span>
0081 <span class="comment">%       December 3, 2018</span>
0082  
0083 <span class="comment">%--------------------BEGIN CODE ----------------------</span>
0084 <span class="comment">%% Get arguments passed to the function and proceed to some verifications</span>
0085 p = inputParser;
0086 
0087 addRequired(p,<span class="string">'A'</span>, @isnumeric );
0088 addRequired(p,<span class="string">'C'</span>, @isnumeric );
0089 addRequired(p,<span class="string">'Q'</span>, @isnumeric );
0090 addRequired(p,<span class="string">'R'</span>, @isnumeric );
0091 addRequired(p,<span class="string">'y'</span>, @isnumeric );
0092 addRequired(p,<span class="string">'x'</span>, @isnumeric );
0093 addRequired(p,<span class="string">'V'</span>, @isnumeric );   
0094 addRequired(p,<span class="string">'U_post'</span>, @isnumeric );
0095 addRequired(p,<span class="string">'D_post'</span>, @isnumeric ); 
0096  
0097 parse(p,A,C,Q,R,y,x,V,U_post, D_post);
0098 
0099 A=p.Results.A;
0100 C=p.Results.C;
0101 Q=p.Results.Q;
0102 R=p.Results.R;
0103 y = p.Results.y;
0104 x=p.Results.x;      
0105 V=p.Results.V;   
0106 U_post=p.Results.U_post;
0107 D_post=p.Results.D_post; 
0108 
0109 
0110 <span class="comment">%% Prediction</span>
0111 xpred = A*x;
0112 Vpred = A*V*A';
0113 Vpred=(Vpred+Vpred')/2;
0114 Vpred=Vpred+Q;
0115 
0116 
0117 <span class="keyword">try</span> [Uq,Dq] = <a href="myUD.html" class="code" title="function [U, D] = myUD(mat,varargin)">myUD</a>(Q, <span class="string">'isError'</span>, false);
0118 <span class="keyword">catch</span>
0119     warning(<span class="string">'UD decomposition failed error.'</span>)
0120 <span class="keyword">end</span>
0121 [x_prior,U_prior,D_prior] = <a href="#_sub2" class="code" title="subfunction [x_prior U_prior D_prior] = thornton(x_post,U_post,D_post,Uq,Dq,varargin)">thornton</a>(x,U_post,D_post,Uq,Dq,A);
0122 
0123 D_prior(D_prior&gt;realmax(<span class="string">'double'</span>))=realmax(<span class="string">'double'</span>);
0124 
0125 missing_idx=isnan(y);
0126 V_prior=U_prior*D_prior*U_prior';
0127 <span class="keyword">if</span> all(missing_idx)
0128     loglik=0;
0129 <span class="keyword">else</span>
0130     <span class="keyword">if</span> any(any(isinf(Q)))
0131         xpred(end)=y(end);
0132         V_prior(<span class="keyword">end</span>,:)=0;
0133         V_prior(:,end)=0;
0134         V_prior(<span class="keyword">end</span>,end)=0;
0135     <span class="keyword">end</span>
0136     
0137     idx_ll=~missing_idx;
0138     y_pred=C(idx_ll,:)*xpred;
0139     Vy_pred=C(idx_ll,:)*V_prior*C(idx_ll,:)'+R(idx_ll,idx_ll);
0140     loglik = <a href="getGaussianProbability.html" class="code" title="function [prob]=getGaussianProbability(x, m, C, varargin)">getGaussianProbability</a>(y(idx_ll),y_pred, Vy_pred, <span class="string">'isLog'</span>, true);
0141 <span class="keyword">end</span>
0142 <span class="keyword">if</span> all(missing_idx)
0143     xnew=x_prior;
0144     U_post=U_prior;
0145     D_post=D_prior;
0146 <span class="keyword">else</span>
0147     <span class="keyword">for</span> i=find(~missing_idx')
0148         [x_prior,U_prior,D_prior] = <a href="#_sub1" class="code" title="subfunction [x_post U_post D_post] = bierman_m(z,R,H,x_prior,U_prior,D_prior)">bierman_m</a>(y(i),R(i,i),C(i,:),x_prior,U_prior,D_prior);
0149     <span class="keyword">end</span>
0150     xnew=x_prior;
0151     U_post=U_prior;
0152     D_post=D_prior;
0153 <span class="keyword">end</span>
0154 
0155 
0156 <span class="comment">%% Update</span>
0157 Vnew=U_post*D_post*U_post';
0158 K=<a href="#_sub3" class="code" title="subfunction [K isSingular] = KalmanGainCalc(P,R,varargin)">KalmanGainCalc</a>(Vpred,R,C);
0159 K(:,missing_idx)=0;
0160 VVnew = A*V - K*C*A*V;
0161 VVnew=triu(VVnew)+triu(VVnew,1)';
0162 
0163 <span class="comment">%--------------------END CODE ------------------------</span>
0164 <span class="keyword">end</span>
0165 
0166 <a name="_sub1" href="#_subfunctions" class="code">function [x_post U_post D_post] = bierman_m(z,R,H,x_prior,U_prior,D_prior)</a>
0167 <span class="comment">%--------------------------------------------------------------------------</span>
0168 <span class="comment">% Syntax:  [x_post U_post D_post] = bierman(z,R,H,x_prior,U_prior,D_prior);</span>
0169 <span class="comment">%</span>
0170 <span class="comment">% Inputs:       z is a scalar measurement</span>
0171 <span class="comment">%               R is the variance of z</span>
0172 <span class="comment">%               H is a row vector of length length(x_prior)</span>
0173 <span class="comment">%               x_prior is the apriori state estimate</span>
0174 <span class="comment">%               [U_prior D_prior] = myUD(P_prior);</span>
0175 <span class="comment">%</span>
0176 <span class="comment">% Outputs:      x_post is the aposteriori state estimate</span>
0177 <span class="comment">%               [U_post D_post] = myUD(P_post);</span>
0178 <span class="comment">%</span>
0179 <span class="comment">% Description:  This function performs the Bierman square root Kalman</span>
0180 <span class="comment">%               filter scalar measurement update. That is, it performs</span>
0181 <span class="comment">%</span>
0182 <span class="comment">%               K = P_prior * H' / (H * P_prior * H' + R);</span>
0183 <span class="comment">%               x_post = x_prior + K * (z - H * x_prior);</span>
0184 <span class="comment">%               P_post = (I - K*H) * P_prior;</span>
0185 <span class="comment">%</span>
0186 <span class="comment">%               but returns x_post, U_post, and D_post, where</span>
0187 <span class="comment">%               [U_post D_post] = myUD(P_post);</span>
0188 <span class="comment">%</span>
0189 <span class="comment">% Author:       Brian Moore</span>
0190 <span class="comment">%               brimoor@umich.edu</span>
0191 <span class="comment">%</span>
0192 <span class="comment">% Date:         June 28, 2012</span>
0193 <span class="comment">%--------------------------------------------------------------------------</span>
0194 
0195 x_post = x_prior;
0196 U_post = U_prior; 
0197 D_post = D_prior;
0198 a = U_post' * H';
0199 b = D_post * a;
0200 dz = z - H * x_prior; 
0201 alpha = R; 
0202 gamma = 1 / alpha; 
0203   <span class="keyword">for</span> j = 1:length(x_prior)
0204   beta   = alpha; 
0205   alpha  = alpha + a(j) * b(j); 
0206   lambda = -a(j) * gamma; 
0207   gamma  = 1 / alpha; 
0208   D_post(j,j) = beta * gamma * D_post(j,j); 
0209     <span class="keyword">for</span> i = 1:j-1 
0210     beta = U_post(i,j); 
0211     U_post(i,j) = beta + b(i) * lambda; 
0212     b(i) = b(i) + b(j) * beta; 
0213     <span class="keyword">end</span>
0214   <span class="keyword">end</span>
0215 x_post = x_post + gamma * dz * b;
0216 <span class="keyword">end</span>
0217 
0218 <a name="_sub2" href="#_subfunctions" class="code">function [x_prior U_prior D_prior] = thornton(x_post,U_post,D_post,Uq,Dq,varargin)</a>
0219 <span class="comment">%--------------------------------------------------------------------------</span>
0220 <span class="comment">% Syntax: [x_prior U_prior D_prior]=thornton(x_post,U_post,D_post,Uq,Dq);</span>
0221 <span class="comment">%         [x_prior U_prior D_prior]=thornton(x_post,U_post,D_post,Uq,Dq,A);</span>
0222 <span class="comment">%</span>
0223 <span class="comment">% Inputs:       x_post is the aposteriori state estimate</span>
0224 <span class="comment">%               [U_post D_post] = myUD(P_post);</span>
0225 <span class="comment">%               [Uq Dq] = myUD(Q);</span>
0226 <span class="comment">%               A is the state transition matrix (can exclude when A is an</span>
0227 <span class="comment">%               identity matrix)</span>
0228 <span class="comment">%</span>
0229 <span class="comment">% Outputs:      x_prior is the apriori state estimate</span>
0230 <span class="comment">%               [U_prior D_prior] = myUD(P_prior);</span>
0231 <span class="comment">%</span>
0232 <span class="comment">% Description:  This function performs the Thornton square root Kalman</span>
0233 <span class="comment">%               filter time update, which employs the modified weighted QR</span>
0234 <span class="comment">%               decomposition. That is, it performs</span>
0235 <span class="comment">%</span>
0236 <span class="comment">%               x_prior = A * x_post;</span>
0237 <span class="comment">%               P_prior = A * P_post * A' + Q;</span>
0238 <span class="comment">%</span>
0239 <span class="comment">%               but returns x_prior, U_prior, and D_prior, where</span>
0240 <span class="comment">%               [U_prior D_prior] = myUD(P_prior);</span>
0241 <span class="comment">%</span>
0242 <span class="comment">% Author:       Brian Moore</span>
0243 <span class="comment">%               brimoor@umich.edu</span>
0244 <span class="comment">%</span>
0245 <span class="comment">% Date:         June 28, 2012</span>
0246 <span class="comment">%--------------------------------------------------------------------------</span>
0247 
0248 tol = 1e-55;
0249 
0250 n = length(x_post);
0251 sigma = 0; <span class="comment">%#ok</span>
0252 dinv = 0; <span class="comment">%#ok</span>
0253 i = 0; <span class="comment">%#ok</span>
0254 j = 0; <span class="comment">%#ok</span>
0255 k = 0; <span class="comment">%#ok</span>
0256 
0257 a1 = zeros(1,n);
0258 a2 = zeros(1,n);
0259 v1 = zeros(1,n);
0260 v2 = zeros(1,n);
0261 D_prior = zeros(n);
0262 
0263 <span class="keyword">if</span> nargin == 6
0264     A = varargin{1};
0265     
0266     x_prior = A * x_post;
0267 
0268     <span class="comment">% Form U_prior = A * U_post</span>
0269     U_prior = A;
0270     <span class="keyword">for</span> i = 1:n
0271         <span class="keyword">for</span> j = n:-1:1
0272             sigma = U_prior(i,j);
0273             <span class="keyword">for</span> k = 1:(j-1)
0274                 sigma = sigma + U_prior(i,k) * U_post(k,j);
0275             <span class="keyword">end</span>
0276             U_prior(i,j) = sigma;
0277         <span class="keyword">end</span>
0278     <span class="keyword">end</span>
0279 <span class="keyword">else</span>
0280     x_prior = x_post;
0281     U_prior = U_post;
0282 <span class="keyword">end</span>
0283 
0284 <span class="keyword">for</span> j = n:-1:1
0285     sigma = 0;
0286     <span class="keyword">for</span> k = 1:n
0287         v1(k) = U_prior(j,k);
0288         a1(k) = D_post(k,k) * v1(k);
0289         sigma = sigma + v1(k) * a1(k);
0290     <span class="keyword">end</span>
0291     <span class="keyword">for</span> k = 1:n
0292         v2(k) = Uq(j,k);
0293         a2(k) = Dq(k,k) * v2(k);
0294         sigma = sigma + v2(k) * a2(k);
0295     <span class="keyword">end</span>
0296     U_prior(j,j) = sigma;
0297     <span class="keyword">if</span> sigma &lt; tol
0298         error(<span class="string">'New error covariance matrix is not positive definite'</span>);
0299     <span class="keyword">end</span>
0300     dinv = 1 / sigma;
0301     <span class="keyword">for</span> k = 1:(j-1)
0302         sigma = 0;
0303         <span class="keyword">for</span> i = 1:n
0304             sigma = sigma + U_prior(k,i) * a1(i);
0305         <span class="keyword">end</span>
0306         <span class="keyword">for</span> i = 1:n
0307             sigma = sigma + Uq(k,i) * a2(i);
0308         <span class="keyword">end</span>
0309         sigma = sigma * dinv;
0310         <span class="keyword">for</span> i = 1:n
0311             U_prior(k,i) = U_prior(k,i) - sigma * v1(i);
0312         <span class="keyword">end</span>
0313         <span class="keyword">for</span> i = 1:n
0314             Uq(k,i) = Uq(k,i) - sigma * v2(i);
0315         <span class="keyword">end</span>
0316         U_prior(j,k) = sigma;
0317     <span class="keyword">end</span>
0318 <span class="keyword">end</span>
0319 
0320 <span class="keyword">for</span> j = 1:n
0321     D_prior(j,j) = U_prior(j,j);
0322     U_prior(j,j) = 1;
0323     <span class="keyword">for</span> i = 1:(j-1)
0324         U_prior(i,j) = U_prior(j,i);
0325         U_prior(j,i) = 0;
0326     <span class="keyword">end</span>
0327 <span class="keyword">end</span>
0328 <span class="keyword">end</span>
0329 
0330 
0331 <a name="_sub3" href="#_subfunctions" class="code">function [K isSingular] = KalmanGainCalc(P,R,varargin)</a>
0332 <span class="comment">%</span>
0333 <span class="comment">% Computes the Kalman Gain K from the formula K = P*H'*(H*P*H'+R)^(-1)</span>
0334 <span class="comment">% WITHOUT explicitly inverting H*P*H'+R by computing its unit Cholesky</span>
0335 <span class="comment">% Decomposition and then applying backsubstitutions on the resulting</span>
0336 <span class="comment">% triangular factors.</span>
0337 <span class="comment">%</span>
0338 
0339 <span class="keyword">if</span> nargin ~= 3
0340     <span class="keyword">try</span>
0341         [U D] = <a href="myUD.html" class="code" title="function [U, D] = myUD(mat,varargin)">myUD</a>(P+R);
0342         isSingular = <span class="string">'false'</span>;
0343         X1 = <a href="#_sub4" class="code" title="subfunction X = myUnitTriSysSol(T,Y,mode)">myUnitTriSysSol</a>(U,P',<span class="string">'upper'</span>);
0344         X2 = X1;
0345         <span class="keyword">for</span> i = 1:size(X2,1)
0346             <span class="keyword">for</span> j = 1:size(X2,2)
0347                 X2(i,j) = X2(i,j) / D(i,i);
0348             <span class="keyword">end</span>
0349         <span class="keyword">end</span>
0350         X3 = <a href="#_sub4" class="code" title="subfunction X = myUnitTriSysSol(T,Y,mode)">myUnitTriSysSol</a>(U',X2,<span class="string">'lower'</span>);
0351         K = X3';
0352     <span class="keyword">catch</span> <span class="comment">%#ok</span>
0353         isSingular = <span class="string">'true'</span>;
0354         K = zeros(size(P,1),size(R,2));
0355     <span class="keyword">end</span>
0356 <span class="keyword">else</span>
0357     H = varargin{1};
0358     <span class="keyword">try</span>
0359         [U D] = <a href="myUD.html" class="code" title="function [U, D] = myUD(mat,varargin)">myUD</a>(H*P*H'+R);
0360         isSingular = <span class="string">'false'</span>;
0361         X1 = <a href="#_sub4" class="code" title="subfunction X = myUnitTriSysSol(T,Y,mode)">myUnitTriSysSol</a>(U,H*P',<span class="string">'upper'</span>);
0362         X2 = X1;
0363         <span class="keyword">for</span> i = 1:size(X2,1)
0364             <span class="keyword">for</span> j = 1:size(X2,2)
0365                 X2(i,j) = X2(i,j) / D(i,i);
0366             <span class="keyword">end</span>
0367         <span class="keyword">end</span>
0368         X3 = <a href="#_sub4" class="code" title="subfunction X = myUnitTriSysSol(T,Y,mode)">myUnitTriSysSol</a>(U',X2,<span class="string">'lower'</span>);
0369         K = X3';
0370     <span class="keyword">catch</span> <span class="comment">%#ok</span>
0371         isSingular = <span class="string">'true'</span>;
0372         K = zeros(size(P,1),size(R,2));
0373     <span class="keyword">end</span>
0374 <span class="keyword">end</span>
0375 <span class="keyword">end</span>
0376 
0377 <a name="_sub4" href="#_subfunctions" class="code">function X = myUnitTriSysSol(T,Y,mode)</a>
0378 <span class="comment">%--------------------------------------------------------------------------</span>
0379 <span class="comment">% Syntax:       X = myUnitTriSysSol(U,Y,'upper');</span>
0380 <span class="comment">%               X = myUnitTriSysSol(L,Y,'lower');</span>
0381 <span class="comment">%</span>
0382 <span class="comment">% Inputs:       When mode == 'upper':</span>
0383 <span class="comment">%               U is an N x N unit upper triangular matrix, and Y is an</span>
0384 <span class="comment">%               N x P matrix.</span>
0385 <span class="comment">%</span>
0386 <span class="comment">%               When mode == 'lower':</span>
0387 <span class="comment">%               L is an N x N unit lower triangular matrix, and Y is an</span>
0388 <span class="comment">%               N x P matrix.</span>
0389 <span class="comment">%</span>
0390 <span class="comment">% Outputs:      X is the N x P matrix such that X = U^(-1) * Y;</span>
0391 <span class="comment">%</span>
0392 <span class="comment">% Description:  This function solves the linear, unit triangular system of</span>
0393 <span class="comment">%               equations Y = T * X using backsubstitution, and returns</span>
0394 <span class="comment">%               X such that X = T^(-1) * Y; (for T = U or T = L)</span>
0395 <span class="comment">%</span>
0396 <span class="comment">% Author:       Brian Moore</span>
0397 <span class="comment">%               brimoor@umich.edu</span>
0398 <span class="comment">%</span>
0399 <span class="comment">% Date:         July 12, 2012</span>
0400 <span class="comment">%--------------------------------------------------------------------------</span>
0401 
0402 [m n] = size(T);
0403 <span class="keyword">if</span> (m ~= n)
0404     error(<span class="string">'Input matrix must be square'</span>);
0405 <span class="keyword">end</span>
0406 
0407 [m p] = size(Y);
0408 
0409 <span class="keyword">if</span> (m ~= n)
0410     error(<span class="string">'U and Y must have same inner dimensions'</span>);
0411 <span class="keyword">end</span>
0412 
0413 X = zeros(n,p);
0414 
0415 <span class="keyword">if</span> strcmpi(mode,<span class="string">'upper'</span>)
0416     <span class="keyword">for</span> j = 1:p
0417         <span class="keyword">for</span> i = n:(-1):1
0418             X(i,j) = Y(i,j);
0419             <span class="keyword">for</span> k = (i+1):n
0420                 X(i,j) = X(i,j) - T(i,k) * X(k,j);
0421             <span class="keyword">end</span>
0422         <span class="keyword">end</span>
0423     <span class="keyword">end</span>
0424 <span class="keyword">elseif</span> strcmpi(mode,<span class="string">'lower'</span>)
0425     <span class="keyword">for</span> j = 1:p
0426         <span class="keyword">for</span> i = 1:n
0427             X(i,j) = Y(i,j);
0428             <span class="keyword">for</span> k = 1:(i-1)
0429                 X(i,j) = X(i,j) - T(i,k) * X(k,j);
0430             <span class="keyword">end</span>
0431         <span class="keyword">end</span>
0432     <span class="keyword">end</span>
0433 <span class="keyword">end</span>
0434 <span class="keyword">end</span>
0435 
0436 
0437</pre></div>
<hr><address>Generated on Tue 05-Feb-2019 11:23:52 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>